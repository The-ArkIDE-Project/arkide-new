{"version":3,"file":"js/addon-entry-custom-block-shape.js","sources":["webpack://GUI/./src/addons/addons/custom-block-shape/_runtime_entry.js","webpack://GUI/./src/addons/addons/custom-block-shape/userscript.js"],"sourcesContent":["/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","export default async function ({ addon, console }) {\n  var BlocklyInstance = await addon.tab.traps.getBlockly();\n\n  (function (Blockly) {\n    const BlockSvg = BlocklyInstance.BlockSvg;\n    var vm = addon.tab.traps.vm;\n\n    const { GRID_UNIT } = BlockSvg;\n\n    function path2SegmentList(path) {\n      const cmds = structuredClone(BlockSvg.CUSTOM_NOTCH_UTIL.supportedCommands);\n      cmds.z = 0;\n      const segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\n    \tconst data = [];\n    \tpath.replace(segment, (_, command, args) => {\n    \t\tlet type = command.toLowerCase();\n    \t\tconst numbers = args.match(/-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig);\n    \t\targs = numbers ? numbers.map(Number) : [];\n\t\t    if (type == \"m\" && args.length > 2) {\n\t\t    \tdata.push([command].concat(args.splice(0, 2)));\n\t\t    \ttype = \"l\";\n\t\t    \tcommand = command == \"m\" ? \"l\" : \"L\";\n\t\t    }\n\n        while (true) {\n          if (args.length == cmds[type]) {\n            args.unshift(command);\n            return data.push(args);\n          }\n          if (args.length < cmds[type]) throw new Error(\"malformed path data\");\n          data.push([command].concat(args.splice(0, cmds[type])));\n        }\n      });\n      return data;\n    }\n\n    function scalePathXY (path, scaleX, scaleY) {\n      const segments = path2SegmentList(path);\n      return segments.map((segment) => {\n        const name = segment[0].toLowerCase();\n        if (name === \"v\") {\n          segment[1] *= scaleY;\n          return segment;\n        }\n        if (name === \"a\") {\n          segment[1] *= scaleX;\n          segment[2] *= scaleY;\n          segment[6] *= scaleX;\n          segment[7] *= scaleY;\n          return segment;\n        }\n\n        return segment.map((val, i) => {\n          if (!i) return val;\n          return val *= i % 2 ? scaleX : scaleY;\n        });\n      }).flat().join(\" \");\n    }\n\n    function updateAllBlocks() {\n      const workspace = Blockly.getMainWorkspace();\n      if (workspace) {\n        if (vm.editingTarget) {\n          vm.emitWorkspaceUpdate();\n        }\n        const flyout = workspace.getFlyout();\n        if (flyout) {\n          const flyoutWorkspace = flyout.getWorkspace();\n          Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.Xml.workspaceToDom(flyoutWorkspace), flyoutWorkspace);\n          workspace.getToolbox().refreshSelection();\n          workspace.toolboxRefreshEnabled_ = true;\n        }\n      }\n    }\n\n    function applyChanges(\n      paddingSize = addon.settings.get(\"paddingSize\"),\n      cornerSize = addon.settings.get(\"cornerSize\"),\n      notchSize = addon.settings.get(\"notchSize\")\n    ) {\n      let multiplier = paddingSize / 100;\n      cornerSize = cornerSize / 100;\n      notchSize = notchSize / 100;\n      BlockSvg.SEP_SPACE_Y = 2 * GRID_UNIT * multiplier;\n      BlockSvg.MIN_BLOCK_X = 16 * GRID_UNIT * multiplier;\n      BlockSvg.MIN_BLOCK_X_OUTPUT = 12 * GRID_UNIT * multiplier;\n      BlockSvg.MIN_BLOCK_X_SHADOW_OUTPUT = 10 * GRID_UNIT * multiplier;\n      BlockSvg.MIN_BLOCK_Y = 12 * GRID_UNIT * multiplier;\n      BlockSvg.EXTRA_STATEMENT_ROW_Y = 8 * GRID_UNIT * multiplier;\n      BlockSvg.MIN_BLOCK_X_WITH_STATEMENT = 40 * GRID_UNIT * multiplier;\n      BlockSvg.MIN_BLOCK_Y_SINGLE_FIELD_OUTPUT = 8 * GRID_UNIT * multiplier;\n      BlockSvg.MIN_BLOCK_Y_REPORTER = 10 * GRID_UNIT * multiplier;\n      BlockSvg.MIN_STATEMENT_INPUT_HEIGHT = 6 * GRID_UNIT * multiplier;\n      BlockSvg.NOTCH_WIDTH = 8 * GRID_UNIT * multiplier;\n      BlockSvg.NOTCH_HEIGHT = 2 * GRID_UNIT * multiplier * notchSize;\n      BlockSvg.NOTCH_START_PADDING = 3 * GRID_UNIT; //* multiplier\n      BlockSvg.ICON_SEPARATOR_HEIGHT = 10 * GRID_UNIT * multiplier;\n\n      BlockSvg.NOTCH_PATH_LEFT =\n        `c 2 0 3 ${1 * notchSize} 4 ${2 * notchSize} ` +\n        `l ${4 * multiplier * notchSize} ${4 * multiplier * notchSize} ` +\n        `c 1 ${1 * notchSize} 2 ${2 * notchSize} 4 ${2 * notchSize} ` +\n        `h ${24 * (multiplier - 0.5)} ` +\n        `c 2 0 3 ${-1 * notchSize} 4 ${-2 * notchSize} ` +\n        `l ${4 * multiplier * notchSize} ${-4 * multiplier * notchSize} ` +\n        `c 1 ${-1 * notchSize} 2 ${-2 * notchSize} 4 ${-2 * notchSize} `\n      BlockSvg.NOTCH_PATH_RIGHT =\n        `h ${(-4 * (cornerSize - 1) - 5 * (1 - notchSize))} ` +\n        `c -2 0 -3 ${1 * notchSize} -4 ${2 * notchSize} ` +\n        `l ${-4 * multiplier * notchSize} ${4 * multiplier * notchSize} ` +\n        `c -1 ${1 * notchSize} -2 ${2 * notchSize} -4 ${2 * notchSize} ` +\n        `h ${-24 * (multiplier - 0.5)} ` +\n        `c -2 0 -3 ${-1 * notchSize} -4 ${-2 * notchSize} ` +\n        `l ${-4 * multiplier * notchSize} ${-4 * multiplier * notchSize} ` +\n        `c -1 ${-1 * notchSize} -2 ${-2 * notchSize} -4 ${-2 * notchSize} `\n\n      /* Custom Notch API Support */\n      const adjustedNotchSize = (multiplier > 1 ? multiplier - 0.05 :\n          multiplier < 1 ? multiplier + 0.05 : multiplier) + ((cornerSize - 1) / 10);\n      BlockSvg.CUSTOM_NOTCHES.forEach((notch) => {\n        if (!notch.ogLeft) {\n          notch.ogLeft = notch.left;\n          notch.ogRight = notch.right;\n        }\n        notch.left = scalePathXY(notch.ogLeft, adjustedNotchSize, notchSize);\n        notch.right = scalePathXY(notch.ogRight, adjustedNotchSize, notchSize);\n      });\n\n      /* Custom Shape API Support */\n      BlockSvg.CUSTOM_SHAPES.forEach((shape) => {\n        if (!shape.ogEmptySize) {\n          shape.ogEmptySize = shape.emptyInputWidth;\n          shape.ogEmptyPath = shape.emptyInputPath;\n        }\n        shape.emptyInputWidth = shape.ogEmptySize * multiplier;\n        shape.emptyInputPath = scalePathXY(shape.ogEmptyPath, multiplier, multiplier);\n        if (shape.emptyInputPath[0] !== \"M\" && shape.emptyInputPath[0] !== \"m\") {\n            shape.emptyInputPath = \"M\" + shape.emptyInputPath;\n        }\n      });\n\n      BlockSvg.INPUT_SHAPE_HEXAGONAL_WIDTH = 12 * GRID_UNIT * multiplier;\n      BlockSvg.INPUT_SHAPE_HEXAGONAL =\n        \"M \" +\n        4 * GRID_UNIT * multiplier +\n        \",0 \" +\n        \" h \" +\n        4 * GRID_UNIT +\n        \" l \" +\n        4 * GRID_UNIT * multiplier +\n        \",\" +\n        4 * GRID_UNIT * multiplier +\n        \" l \" +\n        -4 * GRID_UNIT * multiplier +\n        \",\" +\n        4 * GRID_UNIT * multiplier +\n        \" h \" +\n        -4 * GRID_UNIT +\n        \" l \" +\n        -4 * GRID_UNIT * multiplier +\n        \",\" +\n        -4 * GRID_UNIT * multiplier +\n        \" l \" +\n        4 * GRID_UNIT * multiplier +\n        \",\" +\n        -4 * GRID_UNIT * multiplier +\n        \" z\";\n      BlockSvg.INPUT_SHAPE_ROUND_WIDTH = 12 * GRID_UNIT * multiplier;\n      BlockSvg.INPUT_SHAPE_ROUND =\n        \"M \" +\n        4 * GRID_UNIT * multiplier +\n        \",0\" +\n        \" h \" +\n        4 * GRID_UNIT * multiplier +\n        \" a \" +\n        4 * GRID_UNIT * multiplier +\n        \" \" +\n        4 * GRID_UNIT * multiplier +\n        \" 0 0 1 0 \" +\n        8 * GRID_UNIT * multiplier +\n        \" h \" +\n        -4 * GRID_UNIT * multiplier +\n        \" a \" +\n        4 * GRID_UNIT * multiplier +\n        \" \" +\n        4 * GRID_UNIT * multiplier +\n        \" 0 0 1 0 -\" +\n        8 * GRID_UNIT * multiplier +\n        \" z\";\n\n      BlockSvg.INPUT_SHAPE_SQUARE_WIDTH = 12 * GRID_UNIT * multiplier;\n      BlockSvg.INPUT_SHAPE_SQUARE =\n        'm 0,4A 4,4 0 0,1 4,0'+\n        ' h ' + (12 * GRID_UNIT * multiplier - 2 * 4) +\n        'a 4,4 0 0,1 4,4' +\n        ' v ' + (8 * GRID_UNIT * multiplier - 2 * 4) +\n        ' a 4,4 0 0,1 -4,4' +\n        ' h ' + (-12 * GRID_UNIT * multiplier + 2 * 4) +\n        'a 4,4 0 0,1 -4,-4 z';\n\n      BlockSvg.INPUT_SHAPE_LEAF_WIDTH = 12 * GRID_UNIT * multiplier;\n      BlockSvg.INPUT_SHAPE_LEAF = \n        `M ${6 * GRID_UNIT * multiplier} 0\n        l ${2 * GRID_UNIT * multiplier} 0\n        a ${4 * GRID_UNIT * multiplier} ${4 * GRID_UNIT * multiplier} 0 0 1 ${4 * GRID_UNIT * multiplier} ${4 * GRID_UNIT * multiplier}\n        l 0 ${2.4 * GRID_UNIT * multiplier}\n        a ${1.6 * GRID_UNIT * multiplier} ${1.6 * GRID_UNIT * multiplier} 0 0 1 -${1.6 * GRID_UNIT * multiplier} ${1.6 * GRID_UNIT * multiplier}\n        h -${4 * GRID_UNIT * multiplier}\n        l -${2.4 * GRID_UNIT * multiplier} 0\n        a ${4 * GRID_UNIT * multiplier} ${4 * GRID_UNIT * multiplier} 0 0 1 -${4 * GRID_UNIT * multiplier} -${4 * GRID_UNIT * multiplier}\n        l 0 -${2.4 * GRID_UNIT * multiplier}\n        a ${1.6 * GRID_UNIT * multiplier} ${1.6 * GRID_UNIT * multiplier} 0 0 1 ${1.6 * GRID_UNIT * multiplier} -${1.6 * GRID_UNIT * multiplier}\n        z`;\n\n      BlockSvg.INPUT_SHAPE_PLUS_WIDTH = 12 * GRID_UNIT * multiplier;\n      BlockSvg.INPUT_SHAPE_PLUS = \n        `M ${9 * GRID_UNIT * multiplier} 0\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 1 ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier}\n        l 0 2\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 0 ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier}\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 1 ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier}\n        l 0 4\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 1 -${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier}\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 0 -${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier}\n        l 0 2\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 1 -${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier}\n        h -${6 * GRID_UNIT * multiplier}\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 1 -${GRID_UNIT * multiplier} -${GRID_UNIT * multiplier}\n        l 0 -2\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 0 -${GRID_UNIT * multiplier} -${GRID_UNIT * multiplier}\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 1 -${GRID_UNIT * multiplier} -${GRID_UNIT * multiplier}\n        l 0 -4\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 1 ${GRID_UNIT * multiplier} -${GRID_UNIT * multiplier}\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 0 ${GRID_UNIT * multiplier} -${GRID_UNIT * multiplier}\n        l 0 -2\n        a ${GRID_UNIT * multiplier} ${GRID_UNIT * multiplier} 0 0 1 ${GRID_UNIT * multiplier} -${GRID_UNIT * multiplier} \n        z`;\n\n      BlockSvg.INPUT_SHAPE_HEIGHT = 8 * GRID_UNIT * multiplier;\n      BlockSvg.FIELD_HEIGHT = 8 * GRID_UNIT * multiplier; // NOTE: Determines string input heights\n      BlockSvg.FIELD_WIDTH = 6 * GRID_UNIT * Math.min(multiplier, 1) + 10 * GRID_UNIT * Math.max(multiplier - 1, 0);\n      BlockSvg.FIELD_DEFAULT_CORNER_RADIUS = 4 * GRID_UNIT * multiplier;\n      BlockSvg.EDITABLE_FIELD_PADDING = 1.5 * GRID_UNIT * multiplier;\n      BlockSvg.BOX_FIELD_PADDING = 2 * GRID_UNIT * multiplier;\n      BlockSvg.DROPDOWN_ARROW_PADDING = 2 * GRID_UNIT * multiplier;\n      BlockSvg.FIELD_WIDTH_MIN_EDIT = 8 * GRID_UNIT * multiplier;\n      BlockSvg.INPUT_AND_FIELD_MIN_X = 12 * GRID_UNIT * multiplier;\n      BlockSvg.INLINE_PADDING_Y = 1 * GRID_UNIT * multiplier; // For when reporters are inside reporters\n      BlockSvg.SHAPE_IN_SHAPE_PADDING[1][0] = 5 * GRID_UNIT * multiplier;\n      BlockSvg.SHAPE_IN_SHAPE_PADDING[1][2] = 5 * GRID_UNIT * multiplier;\n      BlockSvg.SHAPE_IN_SHAPE_PADDING[1][3] = 5 * GRID_UNIT * multiplier;\n\n      var originalDropdownObject = BlocklyInstance.FieldDropdown.prototype.positionArrow;\n      BlocklyInstance.FieldDropdown.prototype.positionArrow = function (x) {\n        this.arrowY_ = 11 * multiplier;\n        return originalDropdownObject.call(this, x);\n      };\n\n      // Corner setting\n      BlockSvg.CORNER_RADIUS = (1 * GRID_UNIT * cornerSize * 100) / 100;\n\n      BlockSvg.TOP_LEFT_CORNER_START = \"m 0,\" + BlockSvg.CORNER_RADIUS;\n\n      BlockSvg.TOP_LEFT_CORNER =\n        \"A \" + BlockSvg.CORNER_RADIUS + \",\" + BlockSvg.CORNER_RADIUS + \" 0 0,1 \" + BlockSvg.CORNER_RADIUS + \",0\";\n\n      BlockSvg.TOP_RIGHT_CORNER =\n        \"a \" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS +\n        \" 0 0,1 \" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS;\n\n      BlockSvg.BOTTOM_RIGHT_CORNER =\n        \" a \" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS +\n        \" 0 0,1 -\" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS;\n\n      BlockSvg.BOTTOM_LEFT_CORNER =\n        \"a \" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS +\n        \" 0 0,1 -\" +\n        BlockSvg.CORNER_RADIUS +\n        \",-\" +\n        BlockSvg.CORNER_RADIUS;\n\n      BlockSvg.INNER_TOP_LEFT_CORNER =\n        \" a \" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS +\n        \" 0 0,0 -\" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS;\n\n      BlockSvg.INNER_BOTTOM_LEFT_CORNER =\n        \"a \" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS +\n        \" 0 0,0 \" +\n        BlockSvg.CORNER_RADIUS +\n        \",\" +\n        BlockSvg.CORNER_RADIUS;\n\n      BlockSvg.TOP_RIGHT_CORNER_DEFINE_HAT =\n        \"a \" +\n        BlockSvg.DEFINE_HAT_CORNER_RADIUS +\n        \",\" +\n        BlockSvg.DEFINE_HAT_CORNER_RADIUS +\n        \" 0 0,1 \" +\n        BlockSvg.DEFINE_HAT_CORNER_RADIUS +\n        \",\" +\n        BlockSvg.DEFINE_HAT_CORNER_RADIUS +\n        \" v \" +\n        (1 * GRID_UNIT - BlockSvg.CORNER_RADIUS);\n\n      BlockSvg.STATEMENT_INPUT_INNER_SPACE = 2.8 * GRID_UNIT - 0.9 * GRID_UNIT * cornerSize;\n    }\n\n    function applyAndUpdate(...args) {\n      applyChanges(...args);\n      updateAllBlocks();\n    }\n\n    addon.settings.addEventListener(\"change\", () => applyAndUpdate());\n\n    addon.self.addEventListener(\"disabled\", () => {\n      // Scratch 3.0 blocks\n      applyAndUpdate(100, 100, 100);\n    });\n\n    addon.self.addEventListener(\"reenabled\", () => applyAndUpdate());\n\n    applyAndUpdate();\n  })(window.Blockly);\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAyBA;AACA;AAsBA;AACA;AASA;AACA;AAaA;AACA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAUA;AAUA;AAUA;AAUA;AAUA;AAYA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;;;A","sourceRoot":""}